//go:build ignore
// +build ignore

package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/vmihailenco/msgpack/v5"
)

type ErrorDefinition struct {
	Key     string `json:"key"`
	Message string `json:"message"`
}

func main() {
	inputFile := "errors.json"
	outputDir := "./"

	// Read and parse JSON file containing array of error definitions
	jsonBytes, err := os.ReadFile(inputFile)
	if err != nil {
		panic(fmt.Sprintf("Error reading input file: %v", err))
	}

	var errors []ErrorDefinition
	if err := json.Unmarshal(jsonBytes, &errors); err != nil {
		panic(fmt.Sprintf("Error parsing JSON: %v", err))
	}

	// Generate files for each error definition
	for _, errDef := range errors {
		camelName := keyToCamel(errDef.Key)
		jsonData, msgpackData := generateSerializedData(errDef)
		generateGoFile(outputDir, camelName, errDef.Message, jsonData, msgpackData)
	}
}

func generateSerializedData(errDef ErrorDefinition) ([]byte, []byte) {
	msg := struct {
		Error ErrorDefinition `json:"error" msgpack:"error"`
	}{
		Error: errDef,
	}

	jsonData, err := json.Marshal(msg)
	if err != nil {
		panic(fmt.Sprintf("Error generating JSON: %v", err))
	}

	msgpackData, err := msgpack.Marshal(msg)
	if err != nil {
		panic(fmt.Sprintf("Error generating MessagePack: %v", err))
	}

	return jsonData, msgpackData
}

func generateGoFile(outputDir, camelName, errorMessage string, jsonData, msgpackData []byte) {
	// Generate the complete file content with detailed comments
	fileContent := fmt.Sprintf(`// Code generated by generate.go; DO NOT EDIT.
// This file was automatically generated by generate.go
// Manual edits will be overwritten on next generation.

package msg

// Pre-serialized JSON representation of "%s" error.
// Contains byte array representing JSON structure:
// {
//   "error": {
//     "key": "%s",
//     "message": "%s"
//   }
// }
var error%sJson = []byte{%s}

// Pre-serialized MessagePack representation of "%s" error.
// Binary-optimized format containing the same data as JSON version.
var error%sMsgpack = []byte{%s}

// %s sends a pre-serialized error message to the client.
//
// Parameters:
//   - ctx: Request context (compatible with Fiber, Echo, Gin or other frameworks)
//   - format: Optional format parameter ("json" or "msgpack"). Defaults to JSON.
//
// Returns:
//   - error: Returns an error if there were problems sending the message
//
// Behavior:
// - Automatically sets appropriate Content-Type header
// - Supports multiple frameworks through unified interface
// - Uses pre-serialized data for maximum performance
// - Defaults to JSON format if none specified
func %s(ctx any, format ...string) error {
    return send(ctx, error%sJson, error%sMsgpack, format...)
}
`,
		camelName, strings.ToUpper(keyToSnake(camelName)), errorMessage, camelName, toByteLiteral(jsonData),
		camelName, camelName, toByteLiteral(msgpackData),
		camelName, camelName,
		camelName, camelName)

	outputFile := filepath.Join(outputDir, camelName+".go")
	if err := os.WriteFile(outputFile, []byte(fileContent), 0644); err != nil {
		panic(fmt.Sprintf("Error writing file: %v", err))
	}
}

func keyToCamel(key string) string {
	parts := strings.Split(key, "_")
	for i, p := range parts {
		if len(p) > 0 {
			parts[i] = strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
		}
	}
	return strings.Join(parts, "")
}

func keyToSnake(key string) string {
	var result []rune
	for i, r := range key {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result = append(result, '_')
		}
		result = append(result, r)
	}
	return strings.ToUpper(string(result))
}

func toByteLiteral(b []byte) string {
	var parts []string
	for _, v := range b {
		parts = append(parts, fmt.Sprintf("%d", v))
	}
	return strings.Join(parts, ", ")
}
